---
title: Aurora (part 1)
published: 2025-01-27
description: Express yourself
tags: [Swift, Aurora, Series]
category: Programming
---
import Callout from "$/components/markdown/Callout.astro"
import GitHub from "$/components/markdown/GitHub.astro"

I think we're gonna start off with mathematical expressions, 'cause what good's
a programming language if you can't do basic arithmetic?

## Numbers

Let's delete the autogenerated `Sources/Aurora/Aurora.swift` and
`Tests/AuroraTests/AuroraTests.swift` files first, since those aren't going to
do us much good. Then, let's add a new file,
`Tests/AuroraTests/Parsing/ExpressionTests.swift`.

```console
$ rm Sources/Aurora/Aurora.swift Tests/AuroraTests/AuroraTests.swift
$ mkdir -p Tests/AuroraTests/Parsing
$ touch Tests/AuroraTests/Parsing/ExpressionTests.swift
```

```swift
// ExpressionTests.swift
import Testing
@testable import Aurora

@Suite("Expressions") struct ExpressionTests {
  @Suite("Numbers") struct NumberTests {
    @Test("One-digit number")
    func oneDigitNumber() throws {
      try #expect(Expression(parsing: "1") == .init(value: 1))
    }
  }
}
```

Obviously, this does not compute with the compiler (_this is after adding an
empty `Sources/Aurora/Parsing/Expression.swift` so we get actually helpful
diagnostics_):

```ansi
[1m.../Tests/AuroraTests/Parsing/ExpressionTests.swift:7:17: [31merror:[0m[1m cannot find 'Expression' in scope[0m
    try #expect(Expression(parsing: "1") == .init(value: 1))
[32m                ^~~~~~~~~~[0m

[1m.../Tests/AuroraTests/Parsing/ExpressionTests.swift:7:5: [35mwarning:[0m[1m no calls to throwing functions occur within 'try' expression[0m
    try #expect(Expression(parsing: "1") == .init(value: 1))
[32m    ^[0m
```

<Callout type="tip">
We're gonna get a _lot_ of those "no calls to throwing functions occur within
'try' expression" warnings, so I'll omit them from here on out to try and reduce
noise.
</Callout>

Let's start by adding the bare minimum code needed for it to compile. For the
sake of brevity (and so I don't have to keep manually pasting in ANSI escapes so
y'all aren't left colorblind when reading the diagnostics), I'll just paste that
"bare minimum" in below:

```swift
// Expression.swift
import Parsing

struct Expression: Equatable {
  let value: Int
}

extension Expression {
  init(parsing string: String) throws {
    self.value = try Parse {
      Digits()
    }.parse(string)
  }
}
```

The `Digits` parser simply parses a string of ASCII digits, without any signs or
separators or other junk (as opposed to, say, `Int.parser()`, which is pretty
much just a wrapper for `Int.init?(_ description:)`).

And the test results:[^1]

```ansi
Build complete! (38.94s)
[2mâ—‡[0m Test run started.
[2mâ†³ Testing Library Version: 102 (arm64e-apple-macos13.0)[0m
[2mâ—‡[0m Suite "Expressions" started.
[2mâ—‡[0m Test "One-digit number" started.
[32mâœ”[0m Test "One-digit number" passed after 0.001 seconds.
[32mâœ”[0m Suite "Expressions" passed after 0.001 seconds.
[32mâœ”[0m Test run with 1 test passed after 0.001 seconds.
```

Straight A's so far!

Now let's try multi-digit numbers:

```swift
// ExpressionTests.swift
// ...
@Suite("Expressions") struct ExpressionTests {
  @Suite("Numbers") struct NumberTests {
    // ...
    @Test("Number with several digits")
    func multiDigitNumber() throws {
      try #expect(Expression(parsing: "456") == .init(value: 456))
    }
  }
}
```

```ansi
[32mâœ”[0m Test run with 2 tests passed after 0.004 seconds.
```

### Refactoring

> Oh come _on_, we're refactoring _already_?

I have a feeling we're going to be adding that `init(parsing:)` initializer to a
_lot_ of types, so let's factor that out into a protocol before it gets too out
of hand. Create a new file, `Sources/Aurora/Utilities/Protocols.swift`:

```console
$ mkdir -p Sources/Aurora/Utilities
$ touch Sources/Aurora/Utilities/Protocols.swift
```

```swift
// Protocols.swift
import Parsing

// MARK: - Parsable

@rethrows protocol Parsable {
  associatedtype ParserType: Parser<Substring, Self>

  @ParserBuilder<Substring>
  static var parser: ParserType { get }

  init(parsing string: Substring) rethrows
}

extension Parsable {
  init(parsing string: Substring) throws {
    self = try Self.parser.parse(string)
  }
}
```

<Callout type="tip">
The `Parsing` library makes it _very_ clear that `Substring` is more performant
than `String` when parsing, which is why this protocol uses `Substring`s.
</Callout>

Let's make `Expression` conform to `Parsable`:

```swift
// Expression.swift
// ...
struct Expression: Equatable, Parsable {
  let value: Int

  static var parser: some Parser<Substring, Self> {
    Digits().map(Self.init)
  }
}
```

And a brief sanity check:

```ansi
[32mâœ”[0m Test run with 2 tests passed after 0.003 seconds.
```

Hooray!

## Binary Expressions

Now that we've got simple numbers working, let's try to parse simple binary
operations (like `1 + 2` or `35 / 7`). Let's start by adding a test:

```swift
// ExpressionTests.swift
//...
@Suite("Expressions") struct ExpressionTests {
  // ...
  @Suite("Binary expressions") struct BinaryExpressionTests {
    @Test("One plus two")
    func onePlusTwo() throws {
      try #expect(Expression(parsing: "1+2") == .operation(
        lhs: 1,
        rhs: 2,
        op: .add
      ))
    }
  }
}
```

To make this compile, we need to change `Expression` into an `enum`:

```swift
// Expression.swift
// ...
enum Expression: Equatable, Parsable {
  case number(Int)
  case operation(lhs: Int, rhs: Int, op: Operation)

  static var parser: some Parser<Substring, Self> {
    Digits().map(Self.number)
  }
}
```

Then we can add an `Operation` enum to `Expression`:

```swift
// ...
extension Expression {
  enum Operation: Equatable {
    case add
    case subtract
    case multiply
    case divide
  }
}
```

Trying to compile the tests, it looks like I forgot to replace `init(value:)`
with `number(_:)`. Let's do that:

```swift
// ExpressionTests.swift
// ...
@Suite("Expressions") struct ExpressionTests {
  @Suite("Numbers") struct NumberTests {
    @Test("One-digit number")
    func oneDigitNumber() throws {
      try #expect(Expression(parsing: "1") == .number(1))
    }

    @Test("Number with several digits")
    func multiDigitNumber() throws {
      try #expect(Expression(parsing: "456") == .number(456))
    }
  }
  // ...
}
```

_Now_ we can run the tests.

```ansi
[31mâœ˜[0m Test "One plus two" recorded an issue at ExpressionTests.swift:18:6: Caught error: error: unexpected input
 --> input:1:2
1 | 1+2
  |  ^ expected end of input
```

Oh yeah, we have to actually parse an operator. Thankfully, this is just about
as easy as parsing a number was -- we can use the `OneOf` parser, which acts
similarly to a `switch` statement, choosing the first parser that succeeds.

```swift
// Expression.swift
//...
extension Expression {
  enum Operation: Equatable, Parsable {
    // ...
    static var parser: some Parser<Substring, Self> {
      OneOf<_, Self, _> {
        "+".map { .add }
        "-".map { .subtract }
        "*".map { .multiply }
        "/".map { .divide }
      }
    }
  }
}
```

And add a test (taking advantage of Swift Testing's parameterized tests, because
any and all code repetition is the bane of my existence):

```swift
// ExpressionTests.swift
// ...
@Suite("Expressions") struct ExpressionTests {
  // ...
  @Suite("Binary expressions") struct BinaryExpressionTests {
    @Test("Operators", arguments: [
      "+": Expression.Operation.add,
      "-": .subtract,
      "*": .multiply,
      "/": .divide,
    ])
    func operators(string: Substring, result: Expression.Operation) throws {
      try #expect(Expression.Operation(parsing: string) == result)
    }
    // ...
  }
}
```

```ansi
[32mâœ”[0m Test "Operators" passed after 0.003 seconds.
```

Now we can finally parse some expressions! Let's add support for binary
expressions to `Expression.parser`:

```swift
// Expression.swift
// ...
enum Expression: Equatable, Parsable {
  // ...
  static var parser: some Parser<Substring, Self> {
    OneOf {
      Parse {
        Digits()
        Operation.parser
        Digits()
      }.map { (lhs, op, rhs) in
        Self.operation(lhs: lhs, rhs: rhs, op: op)
      }

      Digits().map(Self.number)
    }
  }
}
```

<Callout type="important">
The `operation` parser _must_ come before the `number` parser -- otherwise, the
`number` parser will _always_ take precedence over the `operation` parser, even
when a number is followed by an operator.
</Callout>

Since the `operation` parser outputs a tuple with the arguments in the wrong
order, we have to reorder them manually in a closure.

```ansi
[32mâœ”[0m Test run with 4 tests passed after 0.004 seconds.
```

### Whitespace

To end off this rather lengthy post, I'll quickly add support for whitespace in
binary expressions. Let's write a test:

```swift
// ExpressionTests.swift
//...
@Suite("Expressions") struct ExpressionTests {
  // ...
  @Suite("Binary expressions") struct BinaryExpressionTests {
    // ...
    @Test("Expression with whitespace")
    func expressionWithWhitespace() throws {
      try #expect(Expression(parsing: "35 / 7") == .operation(
        lhs: 35,
        rhs: 7,
        op: .divide
      ))
    }
  }
}
```

```ansi
[31mâœ˜[0m Test "Expression with whitespace" recorded an issue at ExpressionTests.swift:37:6: Caught error: error: unexpected input
 --> input:1:3
1 | 35 / 7
  |   ^ expected end of input
```

This is absolutely trivial to implement; we just have to sprinkle some
`Whitespace` parsers around.

```swift
// Expression.swift
// ...
enum Expression: Equatable, Parsable {
  // ...
  static var parser: some Parser<Substring, Self> {
    OneOf {
      Parse {
        Digits()
        Whitespace()
        Operation.parser
        Whitespace()
        Digits()
      }.map { (lhs, op, rhs) in
        Self.operation(lhs: lhs, rhs: rhs, op: op)
      }

      Digits().map(Self.number)
    }
  }
}
```

Aaaaaaaand the ultimate test (for today):

```ansi
[2mâ—‡[0m Test run started.
[2mâ†³ Testing Library Version: 102 (arm64e-apple-macos13.0)[0m
[2mâ—‡[0m Suite "Expressions" started.
[2mâ—‡[0m Suite "Numbers" started.
[2mâ—‡[0m Suite "Binary expressions" started.
[2mâ—‡[0m Test "Number with several digits" started.
[2mâ—‡[0m Test "One-digit number" started.
[2mâ—‡[0m Test "Operators" started.
[2mâ—‡[0m Test "One plus two" started.
[2mâ—‡[0m Test "Expression with whitespace" started.
[2mâ—‡[0m Passing 2 arguments string â†’ "+", result â†’ .add to "Operators"
[2mâ—‡[0m Passing 2 arguments string â†’ "*", result â†’ .multiply to "Operators"
[2mâ—‡[0m Passing 2 arguments string â†’ "-", result â†’ .subtract to "Operators"
[2mâ—‡[0m Passing 2 arguments string â†’ "/", result â†’ .divide to "Operators"
[32mâœ”[0m Test "Operators" passed after 0.002 seconds.
[32mâœ”[0m Test "One plus two" passed after 0.003 seconds.
[32mâœ”[0m Test "Expression with whitespace" passed after 0.003 seconds.
[32mâœ”[0m Test "Number with several digits" passed after 0.004 seconds.
[32mâœ”[0m Suite "Binary expressions" passed after 0.004 seconds.
[32mâœ”[0m Test "One-digit number" passed after 0.004 seconds.
[32mâœ”[0m Suite "Numbers" passed after 0.004 seconds.
[32mâœ”[0m Suite "Expressions" passed after 0.004 seconds.
[32mâœ”[0m Test run with 5 tests passed after 0.005 seconds.
```

**Next up: nesting!** So we can do super advanced things like
`((1 + 2) * 3) - (4 * 5)`.[^2]

[^1]: I know it says the testing library is for macOS 13. _Why_ it says that is
  beyond me.
[^2]: For the record, that evaluates to -11.
