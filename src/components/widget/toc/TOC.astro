---
import type { MarkdownHeading } from 'astro'
import type { TOCConfig } from '$/types/config'

import * as R from 'remeda'
import TOCHeading from '$/components/widget/toc/TOCHeading.astro'

interface Props {
  config: TOCConfig
  headings: readonly MarkdownHeading[]
}
const { config, headings: _headings } = Astro.props

const minDepth = R.pipe(_headings, R.map(R.prop('depth')), (x) =>
  Math.min(...x),
)

const headings = R.pipe(
  _headings,
  R.map((x) => R.set(x, 'depth', x.depth - minDepth)),
  R.filter((x) => x.depth < config.depth),
)

let heading1Count = 1
---

<div id="toc-inner-wrapper">
  <div id="toc" class="transition-swup-fade">
    <div class="spacer"></div>

    <table-of-contents>
      {
        headings.map((heading) => (
          <TOCHeading
            id={heading.slug}
            text={heading.text}
            depth={(heading.depth + 1) as 1 | 2}
            h1Index={heading.depth === 0 ? heading1Count++ : heading1Count}
          />
        ))
      }
      <div id="active-indicator"></div>
    </table-of-contents>

    <div class="spacer"></div>
  </div>
</div>

<style lang="scss">
  @use '$/styles/theme' as *;
  @use '$/styles/utils' as *;
  @use '$/styles/variants';

  %hide-scrollbar {
    scrollbar-width: none;
    &::-webkit-scrollbar {
      display: none;
    }
  }

  #toc-inner-wrapper {
    @extend %hide-scrollbar;
    position: fixed;
    top: spacing(14);
    width: var(--toc-width);
    height: calc(100vh - spacing(80));
    overflow: {
      x: hidden;
      y: scroll;
    }

    mask-image: linear-gradient(
      to bottom,
      transparent 0%,
      black spacing(8),
      black calc(100% - spacing(8)),
      transparent 100%
    );

    #toc {
      width: 100%;
      height: 100%;

      .spacer {
        width: 100%;
        height: spacing(8);
      }
    }
  }

  #active-indicator {
    @include transition($properties: all);
    position: absolute;
    left: 0;
    right: 0;
    z-index: -10;
    background-color: var(--toc-btn-hover);
    border: 2px dashed var(--toc-btn-hover) {
      radius: $radius-xl;
    }
  }

  table-of-contents:hover #active-indicator {
    background-color: transparent;
    border-color: var(--toc-btn-active);
  }
</style>

<script>
  import * as R from 'remeda'

  interface TOCEntry {
    id: string
    anchor: HTMLAnchorElement
    section: HTMLElement
    heading: HTMLElement
    isActive: boolean
  }

  class TableOfContents extends HTMLElement {
    readonly tocElement = document.getElementById('toc-inner-wrapper')!
    readonly observer: IntersectionObserver
    anchorNavTarget: HTMLElement | null = null
    tocEntries: TOCEntry[] = []

    constructor() {
      super()
      this.observer = new IntersectionObserver(
        this.markVisibleSection.bind(this),
        { threshold: 0 },
      )
    }

    markVisibleSection(entries: readonly IntersectionObserverEntry[]) {
      for (const entry of entries) {
        const id = entry.target.children[0]?.id
        const tocEntry = this.tocEntries.find((tocEntry) => tocEntry.id === id)
        if (tocEntry !== undefined) {
          tocEntry.isActive = entry.isIntersecting
        }

        if (
          entry.isIntersecting &&
          this.anchorNavTarget === entry.target.firstChild
        ) {
          this.anchorNavTarget = null
        }
      }

      if (!this.tocEntries.some((entry) => entry.isActive)) {
        this.fallback()
      }
      this.update()
    }

    toggleActiveHeading() {
      // find the index of the last element that's active...
      const max = this.tocEntries.findLastIndex((entry) => entry.isActive)
      // ...then find the index of the last element where all the elements after
      // it (until `max`) are active
      const min = this.tocEntries
        .slice(0, max + 1)
        .findLastIndex((entry) => !entry.isActive) + 1

      // so, for example, if we have [false, true, false, true, true, true, false],
      // `max` will be 5, and `min` will be 3

      if (min < 0 || max < 0) {
        return
      }

      for (const entry of this.tocEntries) {
        if (entry.isActive) {
          entry.anchor.classList.add('visible')
        } else {
          entry.anchor.classList.remove('visible')
        }
      }

      const parentOffset = this.tocElement.getBoundingClientRect().top
      const scrollOffset = this.tocElement.scrollTop
      const offset = parentOffset - scrollOffset

      const top = this.tocEntries[min]!.anchor.getBoundingClientRect().top
      const bottom = this.tocEntries[max]!.anchor.getBoundingClientRect().bottom

      document.getElementById('active-indicator')!.style.top =
        `${top - offset}px`
      document.getElementById('active-indicator')!.style.height =
        `${bottom - top}px`
    }

    scrollToActiveHeading() {
      // if the TOC widget can accommodate both the topmost and bottommost
      // items, scroll to the topmost. otherwise, scroll to the bottommost item.

      if (this.anchorNavTarget !== null) {
        return
      }

      const activeHeadings =
        document.querySelectorAll<HTMLElement>('#toc .visible')
      if (activeHeadings.length === 0) {
        return
      }

      const topmost = activeHeadings[0]!
      const bottommost = activeHeadings[activeHeadings.length - 1]!
      const tocHeight = this.tocElement.clientHeight

      const top =
        bottommost.getBoundingClientRect().bottom -
          topmost.getBoundingClientRect().top <
        0.9 * tocHeight
          ? topmost.offsetTop - 32
          : bottommost.offsetTop - tocHeight * 0.8

      this.tocElement.scrollTo({
        top,
        left: 0,
        behavior: 'smooth',
      })
    }

    update() {
      requestAnimationFrame(() => {
        this.toggleActiveHeading()
        this.scrollToActiveHeading()
      })
    }

    fallback() {
      for (const entry of this.tocEntries) {
        const offsetTop = entry.section.getBoundingClientRect().top
        const offsetBottom = entry.section.getBoundingClientRect().bottom

        if (
          (0 < offsetTop && offsetTop < window.innerHeight) ||
          (0 < offsetBottom && offsetBottom < window.innerHeight) ||
          (offsetTop < 0 && offsetBottom > window.innerHeight)
        ) {
          entry.isActive = true
        } else if (offsetTop > window.innerHeight) {
          break
        }
      }
    }

    handleAnchorClick(event: Event) {
      const anchor = event
        .composedPath()
        .find((element) => element instanceof HTMLAnchorElement)

      if (anchor !== undefined) {
        const id = decodeURIComponent(anchor.hash.substring(1))
        const entry = this.tocEntries.find((entry) => entry.id === id)
        this.anchorNavTarget = entry?.heading ?? null
      }
    }

    connectedCallback() {
      document
        .querySelector('.prose')
        ?.addEventListener('animationend', this.init.bind(this), { once: true })
    }

    init() {
      this.tocElement.addEventListener(
        'click',
        this.handleAnchorClick.bind(this),
        {
          capture: true,
        },
      )

      this.tocEntries = R.pipe(
        document.querySelectorAll<HTMLAnchorElement>("#toc a[href^='#']"),
        (x) => Array.from(x),
        R.map((anchor) => {
          const id = decodeURIComponent(anchor.hash.substring(1))
          const heading = document.getElementById(id)!
          const section = heading.parentElement!

          return { id, anchor, section, heading, isActive: false }
        }),
      )

      this.tocEntries.forEach(({ section }) => this.observer.observe(section))

      this.fallback()
      this.update()
    }

    disconnectedCallback() {
      this.tocEntries.forEach(({ section }) => this.observer.unobserve(section))
      this.observer.disconnect()
      this.tocElement.removeEventListener(
        'click',
        this.handleAnchorClick.bind(this),
      )
    }
  }

  customElements.define('table-of-contents', TableOfContents)
</script>
