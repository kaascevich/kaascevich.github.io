---
import type { MarkdownHeading } from 'astro'
import type { TOCConfig } from '$/types/config'

interface Props {
  config: TOCConfig
  class?: string | undefined
  headings: readonly MarkdownHeading[]
}
const { config, class: className, headings: _headings } = Astro.props

const minDepth = Math.min(..._headings.map((heading) => heading.depth))
const headings: readonly MarkdownHeading[] = _headings
  .map((heading) => ({
    ...heading,
    depth: heading.depth - minDepth,
  }))
  .filter((heading) => heading.depth < config.depth)

const removeTailingHash = (text: string): string =>
  text.endsWith('#') ? text.substring(0, text.length - 1) : text

let heading1Count = 1
---

<table-of-contents class:list={[className, 'group']}>
  {
    headings.map((heading) => (
      <a
        href={`#${heading.slug}`}
        class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[--toc-btn-hover] active:bg-[--toc-btn-active] py-2"
      >
        <div
          class:list={[
            'transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold',
            {
              'bg-[--toc-badge-bg] text-[--btn-content]': heading.depth === 0,
              'ml-4': heading.depth === 1,
              'ml-8': heading.depth === 2,
            },
          ]}
        >
          {heading.depth === 0 && heading1Count++}
          {heading.depth === 1 && (
            <div class="transition w-2 h-2 rounded-[0.1875rem] bg-[--toc-badge-bg]" />
          )}
          {heading.depth === 2 && (
            <div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10" />
          )}
        </div>
        <div
          class:list={[
            'transition text-sm',
            heading.depth === 2 ? 'text-30' : 'text-50',
          ]}
        >
          {removeTailingHash(heading.text)}
        </div>
      </a>
    ))
  }
  <div
    id="active-indicator"
    class:list={[
      { hidden: headings.length === 0 },
      '-z-10 absolute bg-[--toc-btn-hover] left-0 right-0 rounded-xl transition-all group-hover:bg-transparent border-2 border-[--toc-btn-hover] group-hover:border-[--toc-btn-active] border-dashed',
    ]}
  >
  </div>
</table-of-contents>

<script>
  class TableOfContents extends HTMLElement {
    tocElement: HTMLElement | null = null
    visibleClass = 'visible'
    observer: IntersectionObserver
    anchorNavTarget: HTMLElement | null = null
    headingIdxMap = new Map<string, number>()
    headings: HTMLElement[] = []
    sections: HTMLElement[] = []
    tocEntries: readonly HTMLAnchorElement[] = []
    active: boolean[] = []
    activeIndicator: HTMLElement | null = null

    constructor() {
      super()
      this.observer = new IntersectionObserver(this.markVisibleSection, {
        threshold: 0,
      })
    }

    markVisibleSection = (entries: readonly IntersectionObserverEntry[]) => {
      entries.forEach((entry) => {
        const id = entry.target.children[0]?.getAttribute('id')
        const idx = id ? this.headingIdxMap.get(id) : undefined
        if (idx !== undefined) {
          this.active[idx] = entry.isIntersecting
        }

        if (
          entry.isIntersecting &&
          this.anchorNavTarget === entry.target.firstChild
        ) {
          this.anchorNavTarget = null
        }
      })

      if (!this.active.includes(true)) {
        this.fallback()
      }
      this.update()
    }

    toggleActiveHeading = () => {
      let i = this.active.length - 1
      let min = this.active.length - 1
      let max = 0
      while (i >= 0 && !this.active[i]) {
        this.tocEntries[i]!.classList.remove(this.visibleClass)
        i -= 1
      }
      while (i >= 0 && this.active[i]) {
        this.tocEntries[i]!.classList.add(this.visibleClass)
        min = Math.min(min, i)
        max = Math.max(max, i)
        i -= 1
      }
      while (i >= 0) {
        this.tocEntries[i]!.classList.remove(this.visibleClass)
        i -= 1
      }
      const parentOffset = this.tocElement?.getBoundingClientRect().top ?? 0
      const scrollOffset = this.tocElement?.scrollTop ?? 0
      const top =
        this.tocEntries[min]!.getBoundingClientRect().top -
        parentOffset +
        scrollOffset
      const bottom =
        this.tocEntries[max]!.getBoundingClientRect().bottom -
        parentOffset +
        scrollOffset
      this.activeIndicator?.setAttribute(
        'style',
        `top: ${top}px; height: ${bottom - top}px`,
      )
    }

    scrollToActiveHeading = () => {
      // if the TOC widget can accommodate both the topmost and bottommost
      // items, scroll to the topmost. otherwise, scroll to the bottommost item.

      if (this.anchorNavTarget || !this.tocElement) {
        return
      }

      const activeHeading = document.querySelectorAll<HTMLDivElement>(
        `#toc .${this.visibleClass}`,
      )
      if (activeHeading.length === 0) {
        return
      }

      const topmost = activeHeading[0]!
      const bottommost = activeHeading[activeHeading.length - 1]!
      const tocHeight = this.tocElement.clientHeight

      let top
      if (
        bottommost.getBoundingClientRect().bottom -
          topmost.getBoundingClientRect().top <
        0.9 * tocHeight
      )
        top = topmost.offsetTop - 32
      else top = bottommost.offsetTop - tocHeight * 0.8

      this.tocElement.scrollTo({
        top,
        left: 0,
        behavior: 'smooth',
      })
    }

    update = () => {
      requestAnimationFrame(() => {
        this.toggleActiveHeading()
        this.scrollToActiveHeading()
      })
    }

    fallback = () => {
      if (this.sections.length === 0) return

      for (let i = 0; i < this.sections.length; i += 1) {
        const offsetTop = this.sections[i]!.getBoundingClientRect().top
        const offsetBottom = this.sections[i]!.getBoundingClientRect().bottom

        if (
          this.isInRange(offsetTop, 0, window.innerHeight) ||
          this.isInRange(offsetBottom, 0, window.innerHeight) ||
          (offsetTop < 0 && offsetBottom > window.innerHeight)
        ) {
          this.markActiveHeading(i)
        } else if (offsetTop > window.innerHeight) {
          break
        }
      }
    }

    markActiveHeading = (idx: number) => {
      this.active[idx] = true
    }

    handleAnchorClick = (event: Event) => {
      const anchor = event
        .composedPath()
        .find((element) => element instanceof HTMLAnchorElement)

      if (1) {
      }

      if (anchor) {
        const id = decodeURIComponent(anchor.hash.substring(1))
        const idx = this.headingIdxMap.get(id)
        this.anchorNavTarget = idx !== undefined ? this.headings[idx]! : null
      }
    }

    isInRange(value: number, min: number, max: number): boolean {
      return min < value && value < max
    }

    connectedCallback() {
      document
        .querySelector('.prose')
        ?.addEventListener('animationend', () => this.init(), { once: true })
    }

    init() {
      this.tocElement = document.getElementById('toc-inner-wrapper')
      if (this.tocElement === null) {
        return
      }

      this.tocElement.addEventListener('click', this.handleAnchorClick, {
        capture: true,
      })

      this.activeIndicator = document.getElementById('active-indicator')

      this.tocEntries = Array.from(
        document.querySelectorAll<HTMLAnchorElement>("#toc a[href^='#']"),
      )
      if (this.tocEntries.length === 0) {
        return
      }

      this.sections = new Array(this.tocEntries.length)
      this.headings = new Array(this.tocEntries.length)
      for (let i = 0; i < this.tocEntries.length; i++) {
        const id = decodeURIComponent(this.tocEntries[i]!.hash.substring(1))
        const heading = document.getElementById(id)
        const section = heading?.parentElement
        if (heading instanceof HTMLElement && section instanceof HTMLElement) {
          this.headings[i] = heading
          this.sections[i] = section
          this.headingIdxMap.set(id, i)
        }
      }
      this.active = new Array(this.tocEntries.length).fill(false)

      this.sections.forEach((section) => this.observer.observe(section))

      this.fallback()
      this.update()
    }

    disconnectedCallback() {
      this.sections.forEach((section) => this.observer.unobserve(section))
      this.observer.disconnect()
      this.tocElement?.removeEventListener('click', this.handleAnchorClick)
    }
  }

  customElements.define('table-of-contents', TableOfContents)
</script>
